#! /bin/bash

# Use TARGETDIR with care. This will cause your objs files to live in the same
# directory regardless of your branch, which may cause weird dependency
# conflicts. If your scripts need to reference the targetdir where the object
# files are stored they should cale make echo_targetdir
# scale make specific variable definitions
# TARGETDIR='obj/generic'

# Set build flags
export MAKEFLAGS="-j $(expr $(nproc) \- 1)"
# unset MAKEFLAGS

export TRACE_FLAGS=--coverage
# unset TRACE_FLAGS

export BUILD_TYPE=debug
# export BUILD_TYPE=opt

export BUILD_SCQAD_CASES=0
# unset BUILD_SCQAD_CASES

export ENABLE_BUILD_TIMER=1
# unset ENABLE_BUILD_TIMER

export NOCHECKSUMTEST=1
# unset NOCHECKSUMTEST

export V=1

export NORECURSION=1
unset NORECURSION

export CCACHE_PREFIX="bear -a -o ~/compile_commands.json"
unset CCACHE_PREFIX

export GTEST_COLOR=1

# scalerc configuration variables
# OPTIONAL BUILD_ROOT forces build to run make from $BUILD_ROOT
SCREWI_USER="jlusby"
BUILDVM_HOSTNAME="buildvm"
SRC_ROOT="/local/scale-product" # on buildvm
COV_DIR="/local/cov"
GIT_ROOT="$HOME/git/scale-product" # on dev pc
AUTOMATED_ROOT="/build/automated"
# SOURCE_FILES='source ~/.shellrc; source ~/.scalerc; source ~/.bash_profile; source ~/.bashrc; source ~/.aliasrc; source /etc/profile.d/ccache.sh'
SOURCE_FILES='source ~/.scalerc'
DOORBELL='tput bel; sleep 1; tput bel'
TIMEOUT=10
END_CMD="$DOORBELL"
# END_CMD="exec bash"
# END_CMD="echo \"Waiting $TIMEOUT seconds before terminating, press enter to exit early\"; read -t $TIMEOUT"
LOG_CMD="less -RN"
# LOG_CMD="$VISUAL"

# helpful aliases
alias scd="cd $SRC_ROOT"
alias tcd="cd ./$TARGETDIR"
SCQAD_DIR="$SRC_ROOT/daemons/scqad"
TESTBEDS="mysql -B --disable-column-names -ureadonly -preadonly -h builddb.lab.local -e \"select testbed from claims where username = '$SCREWI_USER'\" re_ci 2> /dev/null | sed 's/\>/-01.lab.local/g' | uniq"

run_gdb() {
    gdb --args "$@"
    return $?
}

testbeds() {
    echo "$(eval $TESTBEDS | fzf --select-1 --exit-0 --multi)"
    return $?
}

# is first directory inside of second?
is_1_in_2() {
    [ "${1##$2}" != "${1}" ]
    return $?
}

# short alias for make echo_targetdir
targetdir() {
    ECHO_DIR="$SRC_ROOT"
    TARGETDIR="$(BUILD_TYPE=$BUILD_TYPE make -s -C $ECHO_DIR echo_targetdir)"
    echo "$TARGETDIR"
}

get_buildid() {
    cmd="mysql -B --disable-column-names -ureadonly -preadonly -h builddb.lab.local -e \"select build_id from testbeds where testbed = '$1'\" re_ci 2> /dev/null"
    echo $(eval $cmd)
}

jsh() {
    jsh buildvm
}

run_screen() {
    cmd="$SOURCE_FILES; BUILD_ROOT=\"$BUILD_ROOT\" $@; $END_CMD;"
    echo $cmd
    # screen -L -x -R -S "$1" -q bash -c "$cmd"
    case $1 in
    local_scmake)
        nohup stdbuf -oL script -qfc "$cmd" |& tee "$HOME/$1.out"
        # less -RN +F "$HOME/$1.out"
        # tail -f "$HOME/$1.out"
        ;;
    *)
        eval "$@"
        ;;
    esac
}

maybe_run_remote() {
    if hostname | grep -q "buildvm"; then
        run_screen "$@"
    else
        LOCAL_BUILD_ROOT=$BUILD_ROOT
        if is_1_in_2 $PWD $GIT_ROOT; then
            LOCAL_BUILD_ROOT="$SRC_ROOT${PWD##$GIT_ROOT}"
        fi
        scrsync-internal
        # ssh -t $BUILDVM_HOSTNAME "$SOURCE_FILES; BUILD_ROOT=\"$LOCAL_BUILD_ROOT\" run_screen \"$@\""
        ssh -t $BUILDVM_HOSTNAME "$SOURCE_FILES; BUILD_ROOT=\"$LOCAL_BUILD_ROOT\" $@"
        ret=$?
        unset LOCAL_BUILD_ROOT
    fi
    eval $END_CMD
    return $ret
}

run_case() {
    echo "running $0 $@"
    maybe_run_remote local_run_case "$@"
    return $?
}

scmake() {
    maybe_run_remote local_scmake "$@"
}

local_run_case() {
    # TODO enforce this existing
    CASE_NAME="$1"
    TEST_BEDS="$(testbeds)"
    if [ -z "$TEST_BEDS" ]; then
        echo "failed to find any claimed testbeds"
    fi
    TARGETDIR="$(find . -type d -wholename "./obj/*" -and -name "SC001*" | fzf --select-1 --exit-0)"
    if [ -z "$TARGETDIR" ]; then
        echo "Couldnt find targetdir, try running from root directory of the source tree you wish to deploy from"
        return 1
    fi

    echo "hi . $TARGETDIR ."

    # local_make_case $CASE_NAME && \
    for testbed in $TEST_BEDS; do
        # echo "$testbed $TARGETDIR $CASE_NAME"
        $TARGETDIR/scqadleader -b $testbed -d cases/$TARGETDIR -s "runTest{name = '$CASE_NAME'}" ||
            $TARGERTDIR/scqadleader -b $testbed -s "removeTestArtifacts{}"
    done
}

make_case() {
    maybe_run_remote local_make_case "$@"
    return $?
}

local_make_case() (
    CASE_NAME="$1"
    cd $SCQAD_DIR &&
        BUILD_ROOT="" local_scmake ${CASE_NAME}.case
    ret=$?
    echo "the make returned $ret"
    return $ret
)

scqadleader() {
    maybe_run_remote local-scqadleader "$@"
    return $?
}

# I tried making it so this didnt have to be a cd but scqadleader expects to be
# run relative to the tests directory in order for it to resolve their names
# nicely. Doing it this way gives the cleanest command line invocations
local-scqadleader() (
    export BUILD_TYPE
    export TARGETDIR=$(make -s -C $SRC_ROOT echo_targetdir)
    cd $SCQAD_DIR &&
        $TARGETDIR/scqadleader "$@"
    return $?
)

sclog() {
    maybe_run_remote local-sclog "$@"
    return $?
}

local-sclog() {
    filename=$(bfs $SRC_ROOT -type f -name "*.make.txt" -printf "%T+\t%p\n" | sort -r | fzf --select-1 --exit-0 | awk '{print $2}')
    if [ -n "$filename" ]; then
        $LOG_CMD $filename
    fi
    return $?
}

init_mezzanine() {
    maybe_run_remote local_init_mezzanine "$@"
}

# get cluster up and running on a mezzanine test bed
local_init_mezzanine() (
    TEST_BEDS="$(testbeds)"
    unset BUILD_TYPE
    unset TARGETDIR
    TEST_BEDS="$(echo $TEST_BEDS | fzf --select-1 --exit-0)"
    for testbed in $TEST_BEDS; do
        buildID=$(get_buildid $testbed)
        cd "/builds/automated/$buildID/src/daemons/scqad/" &&
            "$(make -s echo_targetdir)/scqadleader" -s -b $testbed 'installSCQADOnCluster {}; configureClusters {}'
    done
    return $?
)

rpmupdate() {
    sudo yum install --enablerepo=SCEL-master --enablerepo=CentOS-base --enablerepo=CentOS-updates $(cat $SRC_ROOT/re/stor/rpmlist_build) --skip-broken -y
    return $?
}

repo_clean() {
    maybe_run_remote local_repo_clean
}

local_repo_clean() {
    cd $SRC_ROOT || return
    git clean -xf
    git checkout -- .
}

scrsync() (
    repo_clean
    scrsync-internal
)

# copy local changes to buildvm source copy
scrsync-internal() (
    cd "$GIT_ROOT" || exit 1

    scp ~/.scalerc $BUILDVM_HOSTNAME:~/

    # rsync -avzh -e ssh "$GIT_ROOT"/.git/* $BUILDVM_HOSTNAME:$SRC_ROOT/.git
    # rsync -avzh -e ssh --exclude-from="$HOME/.gitignore_global" --exclude-from="$GIT_ROOT/.gitignore" "$GIT_ROOT"/* $BUILDVM_HOSTNAME:$SRC_ROOT
    # rsync -avzh -e ssh "$GIT_ROOT"/* $BUILDVM_HOSTNAME:$SRC_ROOT

    FILES=$(git diff -r origin/sb_drsd)
    FILES=$(echo "$FILES" | grep ^diff | gawk '{ print $3 }' | sed 's@^a/@@')
    FILES=$(printf "%s\n$(git ls-files --exclude-standard --others --modified)" "$FILES" | sort -u)
    rsync -avR $(echo $FILES) ${BUILDVM_HOSTNAME}:${SRC_ROOT}

    return $?
)

scrsync-hard() (
    cd "$GIT_ROOT" || exit 1

    scp ~/.scalerc $BUILDVM_HOSTNAME:~/

    # rsync -avzh -e ssh "$GIT_ROOT"/.git/* $BUILDVM_HOSTNAME:$SRC_ROOT/.git
    # rsync -avzh -e ssh --exclude-from="$HOME/.gitignore_global" --exclude-from="$GIT_ROOT/.gitignore" "$GIT_ROOT"/* $BUILDVM_HOSTNAME:$SRC_ROOT
    rsync -avzh -e ssh "$GIT_ROOT"/* $BUILDVM_HOSTNAME:$SRC_ROOT

    #     FILES=$(git diff -r origin/sb_drsd)
    #     FILES=$(echo "$FILES" | grep ^diff | gawk '{ print $3 }' | sed 's@^a/@@')
    #     FILES=$(printf "%s\n$(git ls-files --exclude-standard --others --modified)" "$FILES" | sort -u)
    #     rsync -avR $(echo $FILES) ${BUILDVM_HOSTNAME}:${SRC_ROOT}

    return $?
)

# Wrapper around make that handles scale specific environment variables
local_scmake() {
    # If were not in a subdirectory of the project root then run command from
    # project root
    if [ "x$BUILD_ROOT" != "x" ]; then
        cd $BUILD_ROOT
    elif ! is_1_in_2 $PWD $SRC_ROOT; then
        # dont change directories if you're already locally in the correct
        # directory
        cd $SRC_ROOT
    fi

    echo -e "\n>>>>>>>> \e[94mStarting\e[0m <<<<<<<<"
    echo -e ">> Compiling ${PWD}\n"
    time make "$@"
    RET=$?
    if [ $RET -eq 0 ]; then
        echo -e "\n>>>>>>>> \e[92mDone\e[0m <<<<<<<<"
    else
        echo -e "\n>>>>>>>> \e[91mKilled\e[0m <<<<<<<<"
    fi
    return $RET
}

local_rscmake() (
    mkdir -p $SRC_ROOT/build
    cd $SRC_ROOT/build
    cmake ..
    echo -e "\n>>>>>>>> \e[94mStarting\e[0m <<<<<<<<"
    echo -e ">> Compiling ${PWD}\n"
    time make "$@"
    RET=$?
    if [ $RET -eq 0 ]; then
        echo -e "\n>>>>>>>> \e[92mDone\e[0m <<<<<<<<"
    else
        echo -e "\n>>>>>>>> \e[91mKilled\e[0m <<<<<<<<"
    fi
    return $RET
)

sccmake() {
    maybe_run_remote local_rscmake "$@"
    echo $?
}

local_setup_debug() {
    # wait for sc node show to return something
    while ((1)); do
        sc node show && break
        sleep 1
    done
    echo waiting for scribed...
    # wait for scribed to start
    while ((1)); do
        pidof scribed && break
        sleep 2
    done
    from=$1
    [ -z "$1" ] && from=NODEBUG
    to=$2
    [ -z "$2" ] && to=UPTO_DEBUG
    function dbgconf() {
        local conf="$1"
        local name="${1##*/}"
        cat $conf | sed -e "s/$from/$to/" >"dbg-$name"
        cp $conf ./"backup-$name"
        mv "dbg-$name" $conf
        while ((1)); do
            sccpall "$conf" && break
            sleep 1
        done
    }
    # update scribed.conf to UPTO_DEBUG
    dbgconf /opt/scale/etc/scribed.conf
    # update scaled.conf to UPTO_DEBUG
    dbgconf /opt/scale/etc/scaled.conf
    function dbglogstream() {
        local daemon="$1"
        while ((1)); do
            scdoall sc logstream update daemon $daemon outputpath /var/log/scale/${daemon}.log mask $to && break
            sleep 1
        done
    }
    dbglogstream scribed
    dbglogstream scaled
}

setup_debug() {
    #!/bin/bash
    set -x
    TEST_BEDS="$(testbeds)"
    scp -v ~/.scalerc root@${TEST_BEDS}:.
    ssh -t root@${TEST_BEDS} "$SOURCE_FILES; local_setup_debug \"$2\" \"$3\""
}

local_copy_newest_objects() {
    # determine which objects directory is the most recently compiled one
    NEWEST_FILE=$(find $SRC_ROOT -type f -wholename "*/obj/*" -and ! -wholename "*$(targetdir)/*" -printf "%T+\t%p\n" | sort -r | head -n 1 | awk '{print $2}')
    OLD_TARGETDIR=$(basename $(dirname $NEWEST_FILE))
    # get the name of the new targetdir
    NEW_TARGETDIR=$(basename $(targetdir))
    # for every directory matching newestobjects, copy the directory to newtarget
    for file in $(find $SRC_ROOT -type d -name $OLD_TARGETDIR); do
        NEWFILE=$(echo $file | sed "s/$OLD_TARGETDIR/$NEW_TARGETDIR/")
        echo "$file -> $NEWFILE"
        cp -vr $file $NEWFILE
    done
}

local_compactrun() {
    while ! [ -z "$1" ]; do
        (
            set -o pipefail
            "$1" |& awk 'BEGIN { p[0]="|";p[1]="-" } { printf "\r"p[c % 2]; ++c; } /^\[/ { printf "\r" ; print $0 ; c=0 }' || exit 1
        ) ||
            return 1
        shift
    done
    return 0
}

local_scjobs() {
    # [jlusby@buildvm-fcc497cc-2f84-4300-9501-8277f3db1634 automated]$ /opt/scale/bin/scjobs add --help
    # Usage: /opt/scale/bin/scjobs add --command CMD [<OPTIONS>]
    # Arguments:
    #     CMD                            - BUILD|TEST|INSTALL|PUBLISH|WORKER_CREATE
    #                                    - WORKER_DELETE|WORKER_ENABLE|WORKER_DISABLE
    #                                    - WORKER_BLESS_AUTOMATION
    #                                    - WORKER_UNBLESS_AUTOMATION
    # OPTIONS:
    #     --user USER                    - user owning job (defaults to $USER)
    #     --gerrit-id ID                 - determine user from gerrit-id
    #     --prerequisite ID              - prerequisite job id
    #     --worker-id ID                 - id of a worker in the worker group
    #     --worker-ip IP                 - ip of a worker in the worker group
    #     --worker-sha1 SHA1             - sha1 of worker group
    #     --parameter PARAM=VALUE        - Set job parameter PARAM to VALUE (can be specified multiple times)
    #     --minimal-free-clusters COUNT  - if free clusters < COUNT, do not add the job

    TEST_NAME="VSDTieredAbuseTest"
    BUILD_ID="181562"
    COMMIT_ID="$(mysql -B --disable-column-names -ureadonly -preadonly -h builddb.lab.local -e "select commit_id from builds where build_id = '$BUILD_ID'" re_ci 2>/dev/null)"
    LOAD_PROFILE="default"
    TEST_BEDS="$(mysql -B --disable-column-names -ureadonly -preadonly -h builddb.lab.local -e "select testbed from claims where username = '$SCREWI_USER'" re_ci 2>/dev/null | uniq)"
    COUNT="1"
    OVERRIDE_CLAIM="1"
    TYPE="grinder"
    NOMEZZANINE="1"

    CMD="/opt/scale/bin/scjobs add --user $SCREWI_USER --command test --parameter build_id=$BUILD_ID --parameter commit_id=$COMMIT_ID --parameter load_profile=$LOAD_PROFILE --parameter testbeds=$TEST_BEDS --parameter grinder_testcases=$TEST_NAME --parameter grinder_repeat=1 --parameter override_claim=1 --parameter type=grinder --parameter nomezzanine=1"

    echo $CMD
    eval $CMD
}

scunit() {
    if [ "x$*" = "x" ]; then
        UNIT_TESTS="find . -type f -name \"*UnitTest.cpp\" -exec basename {} .cpp \; | sort -u | fzf --select-1 --exit-0 --multi"
    else
        UNIT_TESTS="echo $*"
    fi

    for var in $(eval "$UNIT_TESTS"); do
        echo "$var blah"
        run_unit "$var"
    done
}

scunit-coverage() {
    scmake &&
        scmake runtest &&
        maybe_run_remote local_save_report "runtest-coverage"
}

run_unit() {
    UNIT_TEST_NAME="$1"
    maybe_run_remote local_run_unit "$UNIT_TEST_NAME"
    rm -rf "$UNIT_TEST_NAME-coverage"
    maybe_run_remote local_save_report "$UNIT_TEST_NAME-coverage"
}

local_save_report() {
    cd "$SRC_ROOT/generated/coverage/unittest" || return 1
    GIT_SHA=$(git rev-parse --short HEAD)
    DEST_DIR="$COV_DIR/revs/$1-$GIT_SHA/"
    if [ -d "$DEST_DIR" ]; then
        rm -rf "$DEST_DIR"
    fi
    mkdir -p "$DEST_DIR"
    cp -r ./* "$DEST_DIR"
    rm -rf "${COV_DIR:?}/$1"
    ln -sf "$DEST_DIR" "$COV_DIR/$1"
}

local_run_unit() {
    UNIT_TEST_NAME="$1"
    UNIT_TEST_PATHS="find \"$SRC_ROOT\" -type f -wholename \"*/$(targetdir)/*\" -name \"*$UNIT_TEST_NAME*\" -name \"*UnitTest\""
    local_scmake pre-runtest
    for var in $(eval "$UNIT_TEST_PATHS"); do
        if [ -f "$var" ]; then
            $var || exit 1
        fi
    done
    local_scmake post-runtest
}

test_unit_determinism() {
    UNIT_TEST_NAME="RSDDistributedRefstateSectorUnitTest"
    UNIT_TEST_PATH="$(find $SRC_ROOT -type f -wholename "*/$(targetdir)/$UNIT_TEST_NAME")"
    UNIT_PATH="$SRC_ROOT/daemons/scribed/unittest"
    NUM_RUNS=20
    if [ -f "$UNIT_TEST_PATH" ]; then
        for ((i = 1; i <= NUM_RUNS; i++)); do
            RUNPATH="/tmp/$UNIT_TEST_NAME/$i"
            local_scmake pre-runtest
            $UNIT_TEST_PATH && (
                mkdir -p $RUNPATH
                cd $UNIT_PATH || exit 1
                gcov "$(find . -type f -name "*.gcda")"
                mv ./*.gcov $RUNPATH
            )
        done
    fi
}

local_repo_rinse() (
    cd $SRC_ROOT || exit 1
    git clean -xfdf
    git submodule foreach --recursive git clean -xfdf
    git reset --hard
    git submodule foreach --recursive git reset --hard
    git submodule update --init --recursive
)

scprep() {
    git fetch && usb=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}')
    git rebase -i "$usb"
}

scgpush() {
    usb=$(git rev-parse --abbrev-ref --symbolic '@{u}' | awk 'BEGIN { FS=\"/\" } {print $2}')
    tags=$1
    if [ -n "$tags" ]; then usb=$usb$tags; fi
    git push origin "HEAD:refs/for/$usb"
}

scls() {
    rev=HEAD
    if [ -n "$1" ]; then rev=$1; fi
    git diff-tree --no-commit-id --name-only -r "$rev"
}

BRANCH="sb_drsd"
PHAB_PROJECT="drsd"
# scwip?
scpush() {
    # arc diff HEAD~ --reviewers="#$PHAB_PROJECT" --plan-changes
    git push origin HEAD:refs/for/$BRANCH
}

scplus1() {
    # arc diff HEAD~ --reviewers="#$PHAB_PROJECT"
    git push origin HEAD:refs/for/$BRANCH/build_type=debug
    changeid=$(git show -s | grep "Change-Id" | awk '{print $2}')
    gerrit_revision=$(ssh -p 29418 gerrit.lab.local gerrit query --current-patch-set "$changeid" | grep -A2 currentPatchSet | grep "revision" | awk '{print $2}')
    ssh -p 29418 gerrit.lab.local gerrit review --code-review +1 "$gerrit_revision"
}
