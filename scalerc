#! /bin/bash

SRC_ROOT="/local/scale-product"
# Use target dir with care. This will cause your objs files to live in the same
# directory regardless of your branch, which may cause weird dependency
# conflicts. If your scripts need to reference the targetdir where the object
# files are stored they should cale make echo_targetdir
# TARGETDIR='obj/generic'
MAKEFLAGS="-j$(expr $(nproc) \- 1)"
# export TRACE_FLAGS=--coverage
BUILD_TYPE=debug
# OPTIONAL BUILD_ROOT forces build to run make from $BUILD_ROOT
GIT_ROOT="$HOME/git/scale-product"
BUILD_SCQAD_CASES=1
alias scd="cd $SRC_ROOT"
alias tcd="cd ./$TARGETDIR"
SCQAD_DIR="$SRC_ROOT/daemons/scqad"
# alias scqadleader='$SCQAD_DIR/$(export BUILD_TYPE; make -s -C $SCQAD_DIR echo_targetdir)/scqadleader'
SCREWI_USER="jlusby"
alias testbeds="mysql -B --disable-column-names -ureadonly -preadonly -h builddb.lab.local -e \"select testbed from claims where username = '$SCREWI_USER'\" re_ci"

maybe_run_remote()
{
    if [ -d $SRC_ROOT ]; then
        "$@"
    else
        ssh -t buildvm "source ~/.bash_profile; source ~/.scalerc; $@"
    fi
}

run_case()
{
    maybe_run_remote local_run_case "$@"
}

local_run_case ()
{
    # TODO enforce this existing
    CASE_NAME="$1"
    TEST_BEDS="$(testbeds)"
    TARGETDIR="$(make -s -C $SRC_ROOT echo_targetdir)"

    local-scqadleader -b "$TEST_BEDS" -d cases/$TARGETDIR -s "runTest{name = '$CASE_NAME'}"
}

scqadleader ()
{
    maybe_run_remote local-scqadleader "$@"
}


# I tried making it so this didnt have to be a cd but scqadleader expects to be
# run relative to the tests directory in order for it to resolve their names
# nicely. Doing it this way gives the cleanest command line invocations
local-scqadleader()
(
    cd $SCQAD_DIR
    export BUILD_TYPE
    export TARGET_DIR=$(make echo_targetdir)
    $TARGET_DIR/scqadleader "$@"
)

sclog ()
{
    maybe_run_remote local-sclog "$@"
}

local-sclog ()
{
    filename=$(bfs $SRC_ROOT -type f -name "*.make.txt" -printf "%T+\t%p\n" | sort -r | fzf --select-1 --exit-0 | awk '{print $2}')
    if [ -n "$filename" ]; then
        $VISUAL $filename
    fi
}


# get cluster up and running on a mezzanine test bed
init_mezzanine ()
{
    buildID="$1";
    testbeds="$2";
    if [ "x$buildID" = "x" ] || [ "x$testbeds" = "x" ]; then
        echo "Error: missing arguments"
        echo "Expected: \"buildID\" \"testbeds\""
        return 1
    fi
    # cd "/builds/automated/$buildID/src/daemons/scqad/" &&
    #     "$(make -s echo_targetdir)/scqadleader" -s -b $testbeds 'installSCQADOnCluster {}; configureClusters {}'
    scqadleader -s -b $testbeds 'installSCQADOnCluster {}; configureClusters {}'
    return $?
}

rpmupdate ()
{
    sudo yum install --enablerepo=SCEL-master --enablerepo=CentOS-base --enablerepo=CentOS-updates $(cat $SRC_ROOT/re/stor/rpmlist_build)  --skip-broken -y
}

# alias to automatically determine if we're on a build vm or not
scmake ()
(
    if [ -d $SRC_ROOT ]; then
        local_scmake "$@"
    else
        if [ "${PWD##$GIT_ROOT}" != "${PWD}" ]; then
            BUILD_ROOT="$SRC_ROOT${PWD##$GIT_ROOT}"
        fi
        scrsync
        remote_scmake "$@"
    fi
)


# copy local changes to buildvm source copy
scrsync ()
{
    CODE_DIR="$HOME/git/scale-product"
    rsync -avzh -e ssh --exclude-from="$HOME/.gitignore_global" --exclude-from="$CODE_DIR/.gitignore" $CODE_DIR/* buildvm:$SRC_ROOT
}


# ssh into buildvm and launch scmake in a screen session
# some cool things this lets me do
#   - If I lose connectivity my build isnt killed
#   - If I want to detach I can just ctrl-a d and ill end up back in the local terminal session
#   - If I run this while another build is in session it reattaches the existing build rather than starting a new one
remote_scmake ()
{
    if [ "x$BUILD_ROOT" = "x" ]; then
        BUILD_ROOT="$SRC_ROOT"
    fi
    # -m forces a new session to be created
    # ssh -t buildvm screen -dRR -s bash -S build "bash -c \"echo hi; source ~/.bash_profile; scmake\""
    ssh -t buildvm "source ~/.bash_profile; export BUILD_ROOT=$BUILD_ROOT; scmake $@"
}


# call make on local build directory and log output
local_scmake ()
{
    screen -dRR -S build -q bash -c "source ~/.bash_profile; BUILD_ROOT=\"$BUILD_ROOT\" screenless-scmake $@"
    tput bel
    tput bel
}


# call make on local build directory and log output
screenless-scmake ()
{
    if [ "x$1" != "x" ]; then
        TARGET_NAME="$1"
    else
        TARGET_NAME="all"
    fi

    # If were not in a subdirectory of the project root then run command from
    # project root
    if [ "x$BUILD_ROOT" != "x" ]; then
        cd $BUILD_ROOT
    elif [ "${PWD##$SRC_ROOT}" == "${PWD}" ]; then
        cd $SRC_ROOT
    fi

    LOGFILE="$TARGET_NAME.make.txt"

    #output stderr and stdout to $LOGFILE and stderr to screen
    (
        echo -e "\n>>>>>>>> \e[94mStarting\e[0m <<<<<<<<"
        echo -e ">> Compiling ${PWD}\n"

        export BUILD_TYPE;
        export MAKEFLAGS;
        # export TARGETDIR;
        export BUILD_SCQAD_CASES;
        time make "$@"

        if [ $? -eq 0 ]; then
            echo -e "\n>>>>>>>> \e[92mDone\e[0m <<<<<<<<"
        else
            echo -e "\n>>>>>>>> \e[91mKilled\e[0m <<<<<<<<"
        fi
    ) \
         |& tee $LOGFILE \
         | grep --color -P "error|"
}
