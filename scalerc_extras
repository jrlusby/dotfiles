#! /bin/bash

run_gdb() {
    gdb --args "$@"
    return $?
}

get_buildid() {
    cmd="mysql -B --disable-column-names -ureadonly -preadonly -h builddb.lab.local -e \"select build_id from testbeds where testbed = '$1'\" re_ci 2> /dev/null"
    echo $(eval $cmd)
}

jsh() {
    jsh "$BUILDVM_HOSTNAME"
}

run_case() {
    echo "running $0 $*"
    maybe_run_remote local_run_case "$@"
    return $?
}

local_run_case() {
    # TODO enforce this existing
    CASE_NAME="$1"
    TEST_BEDS="$(testbeds)"
    if [ -z "$TEST_BEDS" ]; then
        echo "failed to find any claimed testbeds"
    fi
    TARGETDIR="$(find . -type d -wholename "./obj/*" -and -name "SC001*" | fzf --select-1 --exit-0)"
    if [ -z "$TARGETDIR" ]; then
        echo "Couldnt find targetdir, try running from root directory of the source tree you wish to deploy from"
        return 1
    fi

    echo "hi . $TARGETDIR ."

    # local_make_case $CASE_NAME && \
    for testbed in $TEST_BEDS; do
        # echo "$testbed $TARGETDIR $CASE_NAME"
        $TARGETDIR/scqadleader -b $testbed -d cases/$TARGETDIR -s "runTest{name = '$CASE_NAME'}" ||
            $TARGERTDIR/scqadleader -b $testbed -s "removeTestArtifacts{}"
    done
}

make_case() {
    maybe_run_remote local_make_case "$@"
    return $?
}

local_make_case() (
    CASE_NAME="$1"
    cd $SCQAD_DIR &&
        BUILD_ROOT="" local_scmake ${CASE_NAME}.case
    ret=$?
    echo "the make returned $ret"
    return $ret
)

scqadleader() {
    maybe_run_remote local-scqadleader "$@"
    return $?
}

# I tried making it so this didnt have to be a cd but scqadleader expects to be
# run relative to the tests directory in order for it to resolve their names
# nicely. Doing it this way gives the cleanest command line invocations
local-scqadleader() (
    export BUILD_TYPE
    export TARGETDIR=$(make -s -C $SRC_ROOT echo_targetdir)
    cd $SCQAD_DIR &&
        $TARGETDIR/scqadleader "$@"
    return $?
)

sclog() {
    maybe_run_remote local-sclog "$@"
    return $?
}

local-sclog() {
    filename=$(bfs $SRC_ROOT -type f -name "*.make.txt" -printf "%T+\t%p\n" | sort -r | fzf --select-1 --exit-0 | awk '{print $2}')
    if [ -n "$filename" ]; then
        $LOG_CMD $filename
    fi
    return $?
}

init_mezzanine() {
    maybe_run_remote local_init_mezzanine "$@"
}

# get cluster up and running on a mezzanine test bed
local_init_mezzanine() (
    TEST_BEDS="$(testbeds)"
    unset BUILD_TYPE
    unset TARGETDIR
    TEST_BEDS="$(echo $TEST_BEDS | fzf --select-1 --exit-0)"
    for testbed in $TEST_BEDS; do
        buildID=$(get_buildid $testbed)
        cd "/builds/automated/$buildID/src/daemons/scqad/" &&
            "$(make -s echo_targetdir)/scqadleader" -s -b $testbed 'installSCQADOnCluster {}; configureClusters {}'
    done
    return $?
)

rpmupdate() {
    sudo yum install --enablerepo=SCEL-master --enablerepo=CentOS-base --enablerepo=CentOS-updates $(cat $SRC_ROOT/re/stor/rpmlist_build) --skip-broken -y
    return $?
}

local_resize_fs() {
    # requires root
    pvcreate "/dev/$1"
    vgextent VolGroup "/dev/$1"
    lvresize -l +100%FREE --resizefs /dev/VolGroup/lv_root
}

local_setup_debug() {
    # wait for sc node show to return something
    while ((1)); do
        sc node show && break
        sleep 1
    done
    echo waiting for scribed...
    # wait for scribed to start
    while ((1)); do
        pidof scribed && break
        sleep 2
    done
    from=$1
    [ -z "$1" ] && from=NODEBUG
    to=$2
    [ -z "$2" ] && to=UPTO_DEBUG
    function dbgconf() {
        local conf="$1"
        local name="${1##*/}"
        cat $conf | sed -e "s/$from/$to/" >"dbg-$name"
        cp $conf ./"backup-$name"
        mv "dbg-$name" $conf
        while ((1)); do
            sccpall "$conf" && break
            sleep 1
        done
    }
    # update scribed.conf to UPTO_DEBUG
    dbgconf /opt/scale/etc/scribed.conf
    # update scaled.conf to UPTO_DEBUG
    dbgconf /opt/scale/etc/scaled.conf
    function dbglogstream() {
        local daemon="$1"
        while ((1)); do
            scdoall sc logstream update daemon $daemon outputpath /var/log/scale/${daemon}.log mask $to && break
            sleep 1
        done
    }
    dbglogstream scribed
    dbglogstream scaled
}

setup_debug() {
    #!/bin/bash
    set -x
    TEST_BEDS="$(testbeds)"
    scp -v ~/.scalerc root@${TEST_BEDS}:.
    ssh -t root@${TEST_BEDS} "local_setup_debug \"$2\" \"$3\""
}

local_compactrun() {
    while ! [ -z "$1" ]; do
        (
            set -o pipefail
            "$1" |& awk 'BEGIN { p[0]="|";p[1]="-" } { printf "\r"p[c % 2]; ++c; } /^\[/ { printf "\r" ; print $0 ; c=0 }' || return 1
        ) ||
            return 1
        shift
    done
    return 0
}

local_scjobs() {
    # [jlusby@buildvm-fcc497cc-2f84-4300-9501-8277f3db1634 automated]$ /opt/scale/bin/scjobs add --help
    # Usage: /opt/scale/bin/scjobs add --command CMD [<OPTIONS>]
    # Arguments:
    #     CMD                            - BUILD|TEST|INSTALL|PUBLISH|WORKER_CREATE
    #                                    - WORKER_DELETE|WORKER_ENABLE|WORKER_DISABLE
    #                                    - WORKER_BLESS_AUTOMATION
    #                                    - WORKER_UNBLESS_AUTOMATION
    # OPTIONS:
    #     --user USER                    - user owning job (defaults to $USER)
    #     --gerrit-id ID                 - determine user from gerrit-id
    #     --prerequisite ID              - prerequisite job id
    #     --worker-id ID                 - id of a worker in the worker group
    #     --worker-ip IP                 - ip of a worker in the worker group
    #     --worker-sha1 SHA1             - sha1 of worker group
    #     --parameter PARAM=VALUE        - Set job parameter PARAM to VALUE (can be specified multiple times)
    #     --minimal-free-clusters COUNT  - if free clusters < COUNT, do not add the job

    TEST_NAME="VSDTieredAbuseTest"
    BUILD_ID="181562"
    COMMIT_ID="$(mysql -B --disable-column-names -ureadonly -preadonly -h builddb.lab.local -e "select commit_id from builds where build_id = '$BUILD_ID'" re_ci 2>/dev/null)"
    LOAD_PROFILE="default"
    TEST_BEDS="$(mysql -B --disable-column-names -ureadonly -preadonly -h builddb.lab.local -e "select testbed from claims where username = '$SCREWI_USER'" re_ci 2>/dev/null | uniq)"
    COUNT="1"
    OVERRIDE_CLAIM="1"
    TYPE="grinder"
    NOMEZZANINE="1"

    CMD="/opt/scale/bin/scjobs add --user $SCREWI_USER --command test --parameter build_id=$BUILD_ID --parameter commit_id=$COMMIT_ID --parameter load_profile=$LOAD_PROFILE --parameter testbeds=$TEST_BEDS --parameter grinder_testcases=$TEST_NAME --parameter grinder_repeat=1 --parameter override_claim=1 --parameter type=grinder --parameter nomezzanine=1"

    echo $CMD
    eval $CMD
}

test_unit_determinism() {
    UNIT_TEST_NAME="RSDDistributedRefstateSectorUnitTest"
    UNIT_TEST_PATH="$(find $SRC_ROOT -type f -wholename "*/$(targetdir)/$UNIT_TEST_NAME")"
    UNIT_PATH="$SRC_ROOT/daemons/scribed/unittest"
    NUM_RUNS=20
    if [ -f "$UNIT_TEST_PATH" ]; then
        for ((i = 1; i <= NUM_RUNS; i++)); do
            RUNPATH="/tmp/$UNIT_TEST_NAME/$i"
            local_scmake pre-runtest
            $UNIT_TEST_PATH && (
                mkdir -p $RUNPATH
                cd $UNIT_PATH || return 1
                gcov "$(find . -type f -name "*.gcda")"
                mv ./*.gcov $RUNPATH
            )
        done
    fi
}

scprep() {
    git fetch && usb=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}')
    git rebase -i "$usb"
}

scgpush() {
    usb=$(git rev-parse --abbrev-ref --symbolic '@{u}' | awk 'BEGIN { FS=\"/\" } {print $2}')
    tags=$1
    if [ -n "$tags" ]; then usb=$usb$tags; fi
    git push origin "HEAD:refs/for/$usb"
}

scls() {
    rev=HEAD
    if [ -n "$1" ]; then rev=$1; fi
    git diff-tree --no-commit-id --name-only -r "$rev"
}
repo_clean() {
    maybe_run_remote local_repo_clean
}

local_repo_clean() {
    cd "$SRC_ROOT" || return
    git clean -xf
    git checkout -- .
}

local_repo_rinse() (
    cd "$SRC_ROOT" || return 1
    git clean -xfdf
    git submodule foreach --recursive git clean -xfdf
    git reset --hard
    git submodule foreach --recursive git reset --hard
    git submodule update --init --recursive
)

scprep() {
    git fetch && usb=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}')
    git rebase -i "$usb"
}

scpush() {
    git push origin "HEAD:refs/for/$BRANCH/build_type=opt"
}

scplus1() {
    git push origin "HEAD:refs/for/$BRANCH/build_type=debug" 2>&1 | tee /tmp/gerrit.log
    # shellcheck disable=SC2013
    for changeid in $(grep http /tmp/gerrit.log | awk '{print $2}' | awk -F'/' '{print $4}'); do
        echo "$changeid"
        # shellcheck disable=SC2029
        gerrit_revision=$(ssh -p 29418 gerrit.lab.local gerrit query --current-patch-set "$changeid" | grep -A2 currentPatchSet | grep "revision" | awk '{print $2}')
        # shellcheck disable=SC2029
        ssh -p 29418 gerrit.lab.local gerrit review --code-review +1 "$gerrit_revision"
    done
}
